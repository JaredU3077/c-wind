---
alwaysApply: true
description: AI assistance directives for Browserwind development - code generation preferences, error prevention, and project-specific intelligence
---

# Browserwind AI Assistance Directives

## ðŸŽ¯ Code Generation Preferences

### Modern C++ Idioms
When generating code, **always** use:
- Smart pointers (`std::unique_ptr`, `std::shared_ptr`) instead of raw pointers
- Range-based `for` loops: `for (auto& item : container)`
- Auto type deduction: `auto result = calculateValue()`
- Lambda functions for callbacks and algorithms
- `constexpr` for compile-time constants
- RAII pattern for resource management

### Fantasy-Themed Naming
When creating new classes, functions, or variables:
- **Classes**: Use fantasy/medieval terminology
  - `TavernKeeper`, `SpellMerchant`, `QuestGiver`
  - `LongswordSwing`, `MagicBolt`, `EldritchPortal`
- **Systems**: Clear, descriptive names
  - `WorldBuilder`, `TerrainGenerator`, `WeatherSystem`
  - `BehaviorTree`, `PathFinder`, `DecisionMaker`

### Code Structure Patterns
```cpp
// âœ… PREFERRED: Modern C++ patterns
class TavernKeeper : public NPC {
public:
    TavernKeeper() : NPC("Innkeeper", NPCType::MERCHANT) {}

    void interact(Player& player) override {
        auto dialogue = generateDialogue();
        showDialogueWindow(dialogue);
    }

private:
    std::vector<std::string> inventory_;
    std::unique_ptr<DialogueTree> dialogueTree_;
};
```

## ðŸš¨ Error Prevention

### Memory Safety
**Always warn about** and **prevent**:
- Raw pointer usage in game code
- Missing `delete`/`delete[]` calls
- Potential null pointer dereferences
- Memory leaks in RAII classes

### Uninitialized Variables
**Flag immediately**:
```cpp
// âŒ BAD: Uninitialized variables
Vector3 position;        // Use {0, 0, 0}
float health;            // Use 0.0f
bool isAlive;            // Use false

// âœ… GOOD: Always initialize
Vector3 position = {0.0f, 0.0f, 0.0f};
float health = 100.0f;
bool isAlive = true;
```

### Exception Safety
**Suggest exception-safe patterns**:
```cpp
// âœ… PREFERRED: Exception-safe resource management
class ResourceManager {
public:
    ResourceManager() {
        try {
            loadTextures();
            loadSounds();
            initializeSystems();
        } catch (const LoadException& e) {
            LOG_ERROR("Failed to initialize resources: {}", e.what());
            cleanup();  // Always cleanup on failure
            throw;
        }
    }

    ~ResourceManager() {
        cleanup();  // RAII cleanup
    }
};
```

## ðŸ”§ Automatic Code Improvements

### Refactor Suggestions
**Automatically suggest** when encountering:
- Raw pointers â†’ Smart pointers
- C-style arrays â†’ `std::vector` or `std::array`
- Manual loops â†’ Range-based loops
- Magic numbers â†’ Named constants
- Deep inheritance â†’ Composition/ECS

### Pattern Recognition
**Recognize and suggest improvements for**:
- Game object hierarchies â†’ ECS components
- Update/render coupling â†’ Separate systems
- Global state â†’ Dependency injection
- Tight coupling â†’ Observer pattern

## ðŸŽ® Browserwind-Specific Intelligence

### Morrowind-Inspired Features
**Suggest appropriate implementations for**:
- **Quest System**: Objectives, rewards, branching narratives
- **Magic System**: Spells, mana, casting mechanics
- **Faction System**: Reputation, alliances, conflicts
- **Inventory System**: Items, equipment, crafting
- **Dialogue System**: Branching conversations, NPC relationships

### Game Balance Suggestions
**Recommend balancing adjustments for**:
- Combat difficulty curves
- Experience/reward scaling
- Resource management (health, mana, stamina)
- NPC behavior patterns
- World exploration incentives

## ðŸ§ª Testing & Quality Assurance

### Unit Test Generation
**Automatically generate tests for**:
```cpp
// When creating new classes, suggest:
class CombatSystem {
public:
    float calculateDamage(const Weapon& weapon, const Armor& armor) {
        // Implementation
    }
};

// Auto-generate test structure:
TEST(CombatSystem, CalculateDamage) {
    CombatSystem combat;

    Weapon sword{50.0f, DamageType::SLASHING};
    Armor leather{20.0f, ArmorType::LIGHT};

    float damage = combat.calculateDamage(sword, leather);
    EXPECT_GT(damage, 0.0f);
    EXPECT_LT(damage, sword.baseDamage);
}
```

### Performance Monitoring
**Suggest profiling for**:
- Hot functions (called frequently)
- Memory allocations (especially in loops)
- Rendering bottlenecks
- AI pathfinding performance

## ðŸ“ Documentation Standards

### Function Documentation
**Auto-generate documentation templates**:
```cpp
/**
 * Casts a magical spell with the specified parameters
 * @param spell The spell to cast
 * @param target The target entity (can be nullptr for area effects)
 * @param caster The entity casting the spell
 * @return true if spell was cast successfully, false otherwise
 */
bool castSpell(const Spell& spell, Entity* target, const Entity& caster);
```

### Class Documentation
**Suggest comprehensive class docs**:
```cpp
/**
 * Manages the magical spell casting system for Browserwind
 *
 * Responsibilities:
 * - Spell validation and resource checking
 * - Damage calculation and application
 * - Visual effects and particle systems
 * - Cooldown management and spell balancing
 *
 * Dependencies:
 * - Entity system for targets and casters
 * - Resource system for mana management
 * - Particle system for visual effects
 */
class SpellCastingSystem {
    // Implementation
};
```

## ðŸŽ¯ Code Review Suggestions

### Anti-Pattern Detection
**Flag immediately**:
- Singleton overuse (prefer dependency injection)
- God objects (single class doing too many things)
- Tight coupling between systems
- Performance anti-patterns

### Best Practice Enforcement
**Ensure compliance with**:
- Browserwind coding standards
- Performance budgets
- Memory management rules
- Exception safety requirements

## ðŸ”„ Refactoring Assistance

### Code Smell Detection
**Identify and suggest fixes for**:
- Long functions (>50 lines) â†’ Break into smaller functions
- Duplicate code â†’ Extract common functionality
- Complex conditionals â†’ Simplify with early returns
- Large classes â†’ Split into smaller, focused classes

### Modernization Suggestions
**Propose updates to**:
- Legacy C patterns â†’ Modern C++
- Old C++ idioms â†’ C++11/14/17 features
- Performance bottlenecks â†’ Optimized algorithms
- Memory management â†’ Smart pointers and RAII

## ðŸš€ Feature Development Support

### System Architecture
**Suggest appropriate patterns for**:
- New gameplay systems â†’ ECS integration
- UI components â†’ Consistent styling
- Audio systems â†’ Spatial audio setup
- Networking â†’ Client-server architecture

### Integration Guidance
**Provide guidance for**:
- System communication â†’ Event-driven architecture
- Data persistence â†’ Serialization strategies
- Cross-platform compatibility â†’ Abstraction layers
- Performance optimization â†’ Profiling and measurement

## ðŸ“Š Performance Intelligence

### Budget Tracking
**Monitor and suggest improvements for**:
- Frame time budgets (16.67ms at 60 FPS)
- Memory usage limits (2GB desktop target)
- Draw call counts (<1000 per frame)
- CPU/GPU utilization targets

### Optimization Suggestions
**Recommend based on context**:
- Rendering bottlenecks â†’ Batching, LOD, culling
- Memory issues â†’ Pooling, compression, streaming
- CPU bottlenecks â†’ Multithreading, caching, algorithms
- Asset loading â†’ Asynchronous loading, compression

## ðŸŽ¨ UI/UX Consistency

### Interface Patterns
**Maintain consistency across**:
- Button layouts and styling
- Color schemes and themes
- Interaction feedback
- Navigation patterns

### User Experience
**Suggest improvements for**:
- Accessibility features
- Input responsiveness
- Visual feedback systems
- Error handling and user communication

---

## ðŸ’¡ AI Behavior Guidelines

### Response Style
- **Proactive**: Suggest improvements before being asked
- **Educational**: Explain reasoning behind suggestions
- **Context-Aware**: Understand Browserwind's fantasy RPG context
- **Performance-Focused**: Always consider optimization implications

### Code Quality Focus
- **Readability**: Clear, self-documenting code
- **Maintainability**: Modular, well-structured systems
- **Performance**: Efficient algorithms and data structures
- **Safety**: Memory-safe, exception-safe code

### Project Understanding
- **Domain Knowledge**: Morrowind-inspired fantasy RPG mechanics
- **Technical Stack**: C++11/14/17, raylib, modern game development
- **Architecture**: ECS pattern, modular systems, performance-first
- **Goals**: Production-quality game engine with modding support